---
title: MongoDB 简明入门
url: 504.html
id: 504
categories:
  - 未分类
date: 2018-09-09 00:00:00
tags:
---

前
-

多看看书，学点东西。

> 工作是一方好药，让人很容易的走出焦虑

* * *

书中的内容，主要来自于 《mongoDB 权威指南》和 Google 。再加上点自己的思考了。

正文
--

### 简单几句话

MongoDB 是目前的主流 NoSQL 之一

> NoSQL = Not only SQL
> 
> *   [几款主流 NoSql 数据库的对比](https://www.cnblogs.com/vajoy/p/5471308.html)

* * *

*   文档是MangoDB 的基本单元，换关系数据库中的行的概念相似，但是其具体结构复杂的多。
    
*   每个文档，都会有自己的一个特殊的键 `_id` 在文档所处的合集中是唯一的。
    
*   多个件及其关联的值放在一起便是文档。
    
*   合集就是一组文档
    
*   文档之于行，合集之于表。
    
*   集合是没有模式的，在关系数据库里面，每一行有固定的模式。但是在集合中是没有模式的。比如
    
        {'a':123, 'c': 234}
        {'d':354}
    
*   这样的文档就可以存在于一个集合里面。
    
*   Q:既然集合没有模式那么存在的意义是什么呢？
    
    A:实际上集合，我们可以看作是一个数据关系，有关联的数据我们都可以放在一个集合里面，这样的话，就不会存在，在一堆不明事理的数据里面查找
    
    使用 名字对集合进行标识
    
    使用命名空间来划分子合集， 来体现更好的层次关系
    
        blog.posts
        blog.logs
    
*   mongoDB 多个文档组成集合，多个集合便组成了数据库。
    
*   mongoDB ，默认监听端口 **27017**， 使用 **28017** 作为简易的 HTTP 管理。
    
*   mongoDB 自带了一个shell ，其具有完备的 JS 解释器的功能，甚至可以用来运行JS程序, 甚至可以使用 JS 的标准库，且可以使用多行命令。
    
*   在开启的时候，Shell 会自动连接数据库。mongoDB 的真正有魅力的地方在于此：数据库的连接直接赋值给全局变量 db。
    
        > use test    # 选中数据库
        > db      # JS 特性输出当却数据库的字符串
        > db.test # 这里输出 test 库的 test 集合
    

**所以可见 mongoDB 在数据库的访问形式和传统的 关系数据库有了极大的改变。**

* * *

MongoDB 用自己的话讲，它高度的封装了数据库，使用 **键值对** 的方案，很好的绕过了关系数据库中的，严格的数据模式。这样，数据本身的模式回去有了更大的自由，同一个合集下的记录里的内容可以各自不同。这样的数据库就有了更好的灵活性。于是这样，就可以很方便的封装了数据的增删查改的接口。不会想经典关系数据库中的，必须一个 列名一个 value的一样对应。

### MongoDB 基础

正如 mysql 一样，拥有一个SQL语句的解释器，MongoDB 一样有一个，而且功能十分强大。

mongoDB 自带了一个shell ，其具有完备的 JS 解释器的功能，甚至可以用来运行JS程序, 甚至可以使用 JS 的标准库，且可以使用多行命令。

在这个SHELL 里面，数据库本身被封装成了一个全局变量db ，其他的基本操作，都成为了所定义的方法

*   `insert`
*   `find` /`findOne`
*   `update`
*   `remove`

> **tips** ： 由于本身就是Javascript 的封装，所以，我们就可以巧用 db.funcname 来查看这个方法的定义，值得注意的是，这个后面是没有括号的哦，否则就变成了调用

#### Shell 中的 增删查改 简明

> 创建，读取，更新，删除 （CRUD）

在shell中db 已经作为了一个变量，同样的这些操作，也已经被包装成了方法。

* * *

##### 创建

在创建的时候直接使用 `insert`给指定的数据集合，插入一个文档。eg：

    post = {'content': 'hello'} #这里简单的定义一个文档
    db.test.insert(post)    # 响集合内部插入一个文档

* * *

##### 读取

读取文档时候可以使用 `find` 或者 `findOne` 用与文档的检索

    db.test.find()  # 这样会列出集合中的所有文档（默认前20条）
    db.test.findOne()   # 单条查询

当然在查找语句里面是可以使用限定条件的。

    db.test.find({'content': 'hello'})  # 找到所有conten键为 hello 的
    db.test.findOne({'content': 'hello'})   # 同上，找到一条

* * *

##### 读取

使用 `update` 对文档进行更新。同同样的可以使用限定条件

    post = {'content': 'world'} # 定义更新后的文档
    db.test.update({'content': 'hello'}, post)

* * *

##### 删除

删除就直接使用 `remove` ，一样的加上限定条件。

    db.test.remove({'content': 'hello'})

#### 数据类型

在MongoDB 里面不一样，数据的类型，和结构显得更加的多元化。甚至一个键的值可以是：

*   对象ID objectId() 日期 new Date() 代码 function({a=‘hello’}) 数组 \[1,2,3,4,5\] 内嵌文档 如果作为字典理解的话，这个就是一个字典了。

#### ObjectId()

这个方法是比较重要的一个 point 了。实际上这个是一个 MongoDB 的一个全局方法。用于生成一个独一无二的ID ，独一无二这个次是不是已经说明了什么？这里我们使用shell 调用几次：

    > ObjectId()
    5b93fd4eab05d01ee4004b3b
    > ObjectId()
    5b93fe01ab05d01ee4004b3c
    > ObjectId()
    5b93fe08ab05d01ee4004b3d

可以看到这个方法的返回值在不断递增。其具体构成规则如下：

​ 0123 456 78 9 10 11

​ 时间戳 机器 PID 计数器

这个ID 是独一无二的，顾名思义，对象ID ，一个ID 就对应了一个文档。这个 objectId 的方法，会在添加新的文档时自动调用，创建一个 `{'_id': objectId()}` 的键值对。

* * *

执行四次 `db.test.insert({'word':'hello'})` 之后，列出当前合集，可见其内容

_id

word

5b93f56eab05d01ee4004b33

hello

5b93f578ab05d01ee4004b34

hello

5b93f578ab05d01ee4004b35

hello

5b93f579ab05d01ee4004b36

hello

后
-

技术本身在不断的，飞速的迭代着。从 Flash 到 安卓，到 Web。就在过去的短短十年，就有了这样的三座山峰。

![lzxbdl](http://cdn.blog.ihuxu.com/wp-content/uploads/2018/05/530445922_1854089398_AE6F6133-239E-4ad9-8924-82A28BCC4A00.png)

不断的 GO forward ，才能走向浪潮之巅